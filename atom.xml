<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Youlegu&#39;Blog</title>
  
  <subtitle>月光族</subtitle>
  <link href="https://www.misslegu.com/atom.xml" rel="self"/>
  
  <link href="https://www.misslegu.com/"/>
  <updated>2021-03-11T20:13:00.000Z</updated>
  <id>https://www.misslegu.com/</id>
  
  <author>
    <name>幽乐谷</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django中创建自定义错误页面（400，403，404，500）</title>
    <link href="https://www.misslegu.com/2021/03/11/Django%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%EF%BC%88400%EF%BC%8C403%EF%BC%8C404%EF%BC%8C500%EF%BC%89/"/>
    <id>https://www.misslegu.com/2021/03/11/Django%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%EF%BC%88400%EF%BC%8C403%EF%BC%8C404%EF%BC%8C500%EF%BC%89/</id>
    <published>2021-03-11T20:13:00.000Z</published>
    <updated>2021-03-11T20:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览网页的时候，浏览者可能会输入错误的URL，或者访问的网页不再存在是很常见的。这种情况下，你一般都会怎么处理呢？</p><a id="more"></a><h2 id="有三种选择"><a href="#有三种选择" class="headerlink" title="有三种选择"></a>有三种选择</h2><ol><li>重定向到网站的首页；</li><li>显示无聊的400/403/404/500页面，并提供一链接可链接至首页；</li><li>创建一有趣的自定义400/403/404/500错误页面。</li></ol><h2 id="这篇文章主要介绍在Django中如何自定义错误页面，分为下面四个步骤"><a href="#这篇文章主要介绍在Django中如何自定义错误页面，分为下面四个步骤" class="headerlink" title="这篇文章主要介绍在Django中如何自定义错误页面，分为下面四个步骤"></a>这篇文章主要介绍在Django中如何自定义错误页面，分为下面四个步骤</h2><ol><li><p>创建自定义错误页面<br>在项目的templates目录下，创建errors目录，然后在此目录下分别创建好page_400.html，page_403.html，page_404.html，page_500.html。</p></li><li><p>修改settings.py设置<br>修改项目目录下的settings.py，设置 DEBUG=False 以及 ALLOWED_HOST=[“*”] 。这是因为自定义的错误页面只会在非调试模式下生效。</p></li><li><p>修改视图<br>在项目的views.py中，创建如下的错误页面处理方法：</p><p> from django.shortcuts import render</p><p> def bad_request(request):<br>  return render(request,’errors/page_400.html’)</p><p> def permission_denied(request):<br>  return render(request,’errors/page_403.html’)</p><p> def page_not_found(request):<br>  return render(request,’errors/page_404.html’)</p><p> def server_error(request):<br>  return render(request,’errors/page_500.html’)</p></li><li><p>配置urls<br>在项目的urls.py文件中，导入handler400，handler403，handler404，handler500，重新设置错误页面的处理为我们上面views.py里创建的方法：<br> from . import views<br> from django.conf.urls import handler400, handler403, handler404, handler500</p></li></ol><pre><code>urlpatterns = [ url(r&#39;^admin/&#39;, admin.site.urls), url(r&#39;^myapp/&#39;, include(&#39;myapp.urls&#39;, namespace=&#39;myapp&#39;)),] handler400 = views.bad_requesthandler403 = views.permission_deniedhandler404 = views.page_not_foundhandler500 = views.server_error</code></pre><p>至此，重新运行，输入错误的网址可以看到显示的是我们创建的自定义404页面。<br>注意<br>若你使用的是Django 2.0版本，则上述会报如下的错误：<br>“handler404() got an unexpected keyword argument ‘exception’”<br>这是因为在新版本中内置的错误处理方法签名有更改导致的，具体可以看：        <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRqYW5nb3Byb2plY3QuY29tL2VuLzIuMC9yZWYvdmlld3MvI2Vycm9yLXZpZXdz">https://docs.djangoproject.com/en/2.0/ref/views/#error-views<i class="fa fa-external-link-alt"></i></span><br>只需要在修改views.py中代码为：</p><p>```<br>from django.shortcuts import render</p><p>def bad_request(request, exception, template_name=’errors/page_400.html’):<br> return render(request, template_name)</p><p>def permission_denied(request, exception, template_name=’errors/page_403.html’):<br> return render(request, template_name)</p><p>def page_not_found(request, exception, template_name=’errors/page_404.html’):<br> return render(request, template_name)</p><p>def server_error(request, exception, template_name=’errors/page_500.html’):<br> return render(request, template_name)<br> ```bash</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在浏览网页的时候，浏览者可能会输入错误的URL，或者访问的网页不再存在是很常见的。这种情况下，你一般都会怎么处理呢？&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    <category term="django" scheme="https://www.misslegu.com/categories/python/django/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
    <category term="django" scheme="https://www.misslegu.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>python+django+uwsgi使用process</title>
    <link href="https://www.misslegu.com/2021/02/22/python-django-uwsgi%E4%BD%BF%E7%94%A8process/"/>
    <id>https://www.misslegu.com/2021/02/22/python-django-uwsgi%E4%BD%BF%E7%94%A8process/</id>
    <published>2021-02-22T20:11:11.000Z</published>
    <updated>2021-02-22T20:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uwsgi启动django接口使用process会将接口阻塞"><a href="#uwsgi启动django接口使用process会将接口阻塞" class="headerlink" title="uwsgi启动django接口使用process会将接口阻塞"></a>uwsgi启动django接口使用process会将接口阻塞</h2><p>将进程池转换为线程池接口就可以正常使用了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;uwsgi启动django接口使用process会将接口阻塞&quot;&gt;&lt;a href=&quot;#uwsgi启动django接口使用process会将接口阻塞&quot; class=&quot;headerlink&quot; title=&quot;uwsgi启动django接口使用process会将接口阻塞&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python字典底层实现原理</title>
    <link href="https://www.misslegu.com/2021/02/21/python%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://www.misslegu.com/2021/02/21/python%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-21T15:23:00.000Z</published>
    <updated>2021-02-21T15:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字典？"><a href="#什么是字典？" class="headerlink" title="什么是字典？"></a>什么是字典？</h2><p>字典是一系列由键（key）和值（value）配对组成的元素的集合。字典是一个可变容器模型，可以存储任意类型对象。字典实现与哈希算法密不可分（不同的Python版本，算法会不同），不了解哈希算法的童鞋可以先去了解相关知识。</p><a id="more"></a><h2 id="字典是否是有序的？"><a href="#字典是否是有序的？" class="headerlink" title="字典是否是有序的？"></a>字典是否是有序的？</h2><p>在Python3.6之前，字典是无序的，但是Python3.7+，字典是有序的。在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法确保100%有序。</p><h2 id="字典的查询、添加、删除的时间复杂度？"><a href="#字典的查询、添加、删除的时间复杂度？" class="headerlink" title="字典的查询、添加、删除的时间复杂度？"></a>字典的查询、添加、删除的时间复杂度？</h2><p>字典的查询、添加、删除的平均时间复杂度都是O(1)（为什么是平均时间复杂度，文章后面会讲解到），相比列表与元祖，性能更优。</p><p>四. 字典的实现原理？<br>首先说说Python3.6之前的无序字典<br>字典底层是维护一张哈希表（见下图），我们可以把哈希表看成一个列表，哈希表中的每一个元素又存储了哈希值（hash）、键（key）、值（value）3个元素。（Python3.6之前）</p><p>enteies = [<br>    [‘–’, ‘–’, ‘–’],<br>    [hash, key, value],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [hash, key, value],<br>]<br>由上可以见哈希表的存储结构，我们也可以看出，元素之间有一些空元素，我们通过增加一个元素来讲解具体实现。</p><p>计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（DictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的enteies哈希表中的下标位置<br>若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等<br>如果key相等就表示key已存在，则更新value值<br>如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止。<br>以上介绍了老字典的实现过程，下面我们带入具体的数值来介绍。</p><h3 id="给字典添加一个值，key为hello，value为word"><a href="#给字典添加一个值，key为hello，value为word" class="headerlink" title="给字典添加一个值，key为hello，value为word"></a>给字典添加一个值，key为hello，value为word</h3><p>my_dict[‘hello’] = ‘word’</p><h3 id="假设是一个空列表，hash表初始如下"><a href="#假设是一个空列表，hash表初始如下" class="headerlink" title="假设是一个空列表，hash表初始如下"></a>假设是一个空列表，hash表初始如下</h3><p>enteies = [<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>]</p><p>hash_value = hash(‘hello’)  # 假设值为 12343543 注：以下计算值不等于实际值，仅为演示使用<br>index = hash_value &amp; ( len(enteies) - 1)  # 假设index值计算后等于3，具体的hash算法本文不做介绍</p><h3 id="下面会将值存在enteies中"><a href="#下面会将值存在enteies中" class="headerlink" title="下面会将值存在enteies中"></a>下面会将值存在enteies中</h3><p>enteies = [<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [12343543, ‘hello’, ‘word’],  # index=3<br>    [‘–’, ‘–’, ‘–’],<br>]</p><h3 id="我们继续向字典中添加值"><a href="#我们继续向字典中添加值" class="headerlink" title="我们继续向字典中添加值"></a>我们继续向字典中添加值</h3><p>my_dict[‘color’] = ‘green’</p><p>hash_value = hash(‘color’)  # 假设值为 同样为12343543<br>index = hash_value &amp; ( len(enteies) - 1)  # 假设index值计算后同样等于3</p><h3 id="下面会将值存在enteies中-1"><a href="#下面会将值存在enteies中-1" class="headerlink" title="下面会将值存在enteies中"></a>下面会将值存在enteies中</h3><p>enteies = [<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [‘–’, ‘–’, ‘–’],<br>    [12343543, ‘hello’, ‘word’],  # 由于index=3的位置已经被占用，且key不一样，所以判定为hash冲突，继续向下寻找<br>    [12343543, ‘color’, ‘green’],  # 找到空余位置，则保存<br>]<br>通过上面的讲解，已经了解了字典的插入的过程，可以更具此过程分析出字典查找、插入的执行过程，这里就不过多赘述。我们可以看到，不同的key计算的出的index值是不一样的，在enteies中插入的位置不一样，所以当我们遍历字典的时候，字段的顺序与我们插入的顺序是不相同的。</p><p>我们同样可以发现，enteies表是稀疏的，随着我们插入的值不同，enteies表会越来越稀疏（enteies也是一个会动态扩展长度的，每一此扩展长度，都会重新计算所有key的hash值），所以新的字典实现就随之出现。</p><ol start="2"><li>Python3.7+后的新的实现方式</li></ol><p>老字典使用一张hash，而新字典还使用了一张Indices表来辅助。下来列出新的结构：</p><p>indices = [None, None, index, None, index, None, index]<br>enteies = [<br>    [hash0, key0, value0],<br>    [hash1, key1, value1],<br>    [hash2, key2, value2]<br>]<br>下面为具体的实现过程：</p><p>计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（IndicesDictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的indices的下标位置（注：具体算法与Python版本相关，并不一定一样）<br>得到index后，会找到indices的位置，但是此位置不是存的hash值，而是存的len(enteies)，表示该值在enteies中的位置<br>如果出现hash冲突，则处理方式与老字典处理方式类似<br>下面带入实际实现过程：</p><h3 id="给字典添加一个值，key为hello，value为word-1"><a href="#给字典添加一个值，key为hello，value为word-1" class="headerlink" title="给字典添加一个值，key为hello，value为word"></a>给字典添加一个值，key为hello，value为word</h3><p>my_dict[‘hello’] = ‘word’</p><h3 id="假设是一个空列表，hash表初始如下-1"><a href="#假设是一个空列表，hash表初始如下-1" class="headerlink" title="假设是一个空列表，hash表初始如下"></a>假设是一个空列表，hash表初始如下</h3><p>indices = [None, None, None, None, None, None]<br>enteies = []</p><p>hash_value = hash(‘hello’)  # 假设值为 12343543<br>index = hash_value &amp; ( len(indices) - 1)  # 假设index值计算后等于3，具体的hash算法本文不做介绍</p><h3 id="会找到indices的index为3的位置，并插入enteies的长度"><a href="#会找到indices的index为3的位置，并插入enteies的长度" class="headerlink" title="会找到indices的index为3的位置，并插入enteies的长度"></a>会找到indices的index为3的位置，并插入enteies的长度</h3><p>indices = [None, None, None, 0, None, None]</p><h3 id="此时enteies会插入第一个元素"><a href="#此时enteies会插入第一个元素" class="headerlink" title="此时enteies会插入第一个元素"></a>此时enteies会插入第一个元素</h3><p>enteies = [<br>    [12343543, ‘hello’, ‘word’]<br>]</p><h3 id="我们继续向字典中添加值-1"><a href="#我们继续向字典中添加值-1" class="headerlink" title="我们继续向字典中添加值"></a>我们继续向字典中添加值</h3><p>my_dict[‘haimeimei’] = ‘lihua’</p><p>hash_value = hash(‘haimeimei’)  # 假设值为 34323545<br>index = hash_value &amp; ( len(indices) - 1)  # 假设index值计算后同样等于 0</p><h3 id="会找到indices的index为0的位置，并插入enteies的长度"><a href="#会找到indices的index为0的位置，并插入enteies的长度" class="headerlink" title="会找到indices的index为0的位置，并插入enteies的长度"></a>会找到indices的index为0的位置，并插入enteies的长度</h3><p>indices = [1, None, None, 0, None, None]</p><h3 id="此时enteies会插入第一个元素-1"><a href="#此时enteies会插入第一个元素-1" class="headerlink" title="此时enteies会插入第一个元素"></a>此时enteies会插入第一个元素</h3><p>enteies = [<br>    [12343543, ‘hello’, ‘word’],<br>    [34323545, ‘haimeimei’, ‘lihua’]<br>]<br>我们在来看一下查询字典的具体过程：</p><h3 id="下面是一个字典与字典的存储"><a href="#下面是一个字典与字典的存储" class="headerlink" title="下面是一个字典与字典的存储"></a>下面是一个字典与字典的存储</h3><p>more_dict = {‘name’: ‘张三’, ‘sex’: ‘男’, ‘age’: 10, ‘birth’: ‘2019-01-01’}</p><h3 id="数据实际存储"><a href="#数据实际存储" class="headerlink" title="数据实际存储"></a>数据实际存储</h3><p>indices = [None, 2, None, 0, None, None, 1, None, 3]<br>enteies = [<br>    [34353243, ‘name’, ‘张三’],<br>    [34354545, ‘sex’, ‘男’],<br>    [23343199, ‘age’, 10],<br>    [00956542, ‘birth’, ‘2019-01-01’],<br>]</p><p>print(more_dict[‘age’])  # 当我们执行这句时</p><p>hash_value = hash(‘age’)  # 假设值为 23343199<br>index = hash_value &amp; ( len(indices) - 1)  # index = 1</p><p>entey_index = indices[1]  # 数据在enteies的位置是2<br>value = enteies[entey_index]  # 所以找到值为 enteies[2]<br>由上可以看出，新字典存储数据本身的enteies并不会稀疏，由indices来维护具体存储的位置，enteies中的数据是和插入的数据是一样的，所以新的字典是有序的。</p><p>上面的例子没有说明冲突的解决方案，大家可以自己思考思考。</p><h2 id="时间复杂度说明"><a href="#时间复杂度说明" class="headerlink" title="时间复杂度说明"></a>时间复杂度说明</h2><p>我们在上面提到了，字典的平均时间复杂度是O(1)，因为字典是通过哈希算法来实现的，哈希算法不可避免的问题就是hash冲突，Python字典发生哈希冲突时，会向下寻找空余位置，直到找到位置。如果在计算key的hash值时，如果一直找不到空余位置，则字典的时间复杂度就变成了O(n)了，所以Python的哈希算法就显得非常重要了。Python字典的哈希算法，会尽量保证哈希值计算出的index是平均分布且每一个值之间有剩余位置，例如:</p><p>[index, None, None, None, index, None, None, None]<br>及index尽量只为 0, 3, 5, 7类似值，保证在发生哈希冲突时，能很快的找到空余位置。</p><h2 id="字典的key能使用什么值？"><a href="#字典的key能使用什么值？" class="headerlink" title="字典的key能使用什么值？"></a>字典的key能使用什么值？</h2><p>Python字典的key可以使用字符串（str），整型（int），元祖（tuple）等。我们已经知道，字典是通过哈希算法来计算key的值，所以key必须为可哈希的，list不能作为字典的key，因为list是可变的及不可哈希的对象，所以不能作为字典的key。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是字典？&quot;&gt;&lt;a href=&quot;#什么是字典？&quot; class=&quot;headerlink&quot; title=&quot;什么是字典？&quot;&gt;&lt;/a&gt;什么是字典？&lt;/h2&gt;&lt;p&gt;字典是一系列由键（key）和值（value）配对组成的元素的集合。字典是一个可变容器模型，可以存储任意类型对象。字典实现与哈希算法密不可分（不同的Python版本，算法会不同），不了解哈希算法的童鞋可以先去了解相关知识。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>django model的一些常用查询指令</title>
    <link href="https://www.misslegu.com/2021/01/20/django-model%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.misslegu.com/2021/01/20/django-model%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/</id>
    <published>2021-01-20T10:03:00.000Z</published>
    <updated>2021-01-20T10:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>__exact 精确等于 like ‘aaa’  __iexact 精确等于 忽略大小写 ilike ‘aaa’  __contains 包含 like ‘%aaa%’__icontains 包含 忽略大小写 ilike ‘%aaa%’，但是对于sqlite来说，contains的作用效果等同于icontains。</code></pre><a id="more"></a><pre><code>__gt 大于__gte 大于等于__lt 小于__lte 小于等于__in 存在于一个list范围内__startswith 以…开头__istartswith 以…开头 忽略大小写__endswith 以…结尾__iendswith 以…结尾，忽略大小写__range 在…范围内__year 日期字段的年份__month 日期字段的月份__day 日期字段的日__isnull=True/False__isnull=True 与 __exact=None的区别</code></pre>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;__exact 精确等于 like ‘aaa’  
__iexact 精确等于 忽略大小写 ilike ‘aaa’  
__contains 包含 like ‘%aaa%’
__icontains 包含 忽略大小写 ilike ‘%aaa%’，但是对于sqlite来说，contains的作用效果等同于icontains。&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    <category term="django" scheme="https://www.misslegu.com/categories/python/django/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
    <category term="django" scheme="https://www.misslegu.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>python-GIL全局解释器</title>
    <link href="https://www.misslegu.com/2021/01/17/python-GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>https://www.misslegu.com/2021/01/17/python-GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8/</id>
    <published>2021-01-17T21:52:00.000Z</published>
    <updated>2021-01-17T21:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>    在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核    同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。    GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以    把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，    拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操    作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的    python在使用多线程的时候，调用的是c语言的原生过程。</code></pre><a id="more"></a><pre><code>                        python针对不同类型的代码执行效率也是不同的    1、CPU密集型代码（各种循环处理、计算等），在这种情况下，由于计算工作多，ticks技术很快就会达到阀值，然后出发GIL的    释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。    2、IO密集型代码（文件处理、网络爬虫等设计文件读写操作），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，    造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序的执行    效率）。所以python的多线程对IO密集型代码比较友好。主要要看任务的类型，我们把任务分为I/O密集型和计算密集型，而多线程在切换中又分为I/O切换和时间切换。如果任务属于是I/O密集型，若不采用多线程，我们在进行I/O操作时，势必要等待前面一个I/O任务完成后面的I/O任务才能进行，在这个等待的过程中，CPU处于等待状态，这时如果采用多线程的话，刚好可以切换到进行另一个I/O任务。这样就刚好可以充分利用CPU避免CPU处于闲置状态，提高效率。但是如果多线程任务都是计算型，CPU会一直在进行工作，直到一定的时间后采取多线程时间切换的方式进行切换线程，此时CPU一直处于工作状态，此种情况下并不能提高性能，相反在切换多线程任务时，可能还会造成时间和资源的浪费，导致效能下降。这就是造成上面两种多线程结果不能的解释。</code></pre><p>结论:I/O密集型任务，建议采取多线程，还可以采用多进程+协程的方式(例如:爬虫多采用多线程处理爬取的数据)；对于计算密集型任务，python此时就不适用了。</p>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;    在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核
    同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。
    GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以
    把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，
    拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操
    作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的
    python在使用多线程的时候，调用的是c语言的原生过程。&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python多线程详解</title>
    <link href="https://www.misslegu.com/2021/01/17/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.misslegu.com/2021/01/17/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-01-17T20:06:00.000Z</published>
    <updated>2021-01-17T20:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><pre><code>  线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。  线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所  拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</code></pre><a id="more"></a><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><pre><code>线程在程序中是独立的、并发的执行流。与分隔的进程相比，进程中线程之间的隔离程度要小，它们共享内存、文件句柄和其他进程应有的状态。因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程之中拥有独立的内存单元，而多个线程共享内存，从而极大的提升了程序的运行效率。线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性，多个线程共享一个进程的虚拟空间。线程的共享环境包括进程代码段、进程的共有数据等，利用这些共享的数据，线程之间很容易实现通信。操作系统在创建进程时，必须为改进程分配独立的内存空间，并分配大量的相关资源，但创建线程则简单得多。因此，使用多线程来实现并发比使用多进程的性能高得要多。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>使用多线程编程具有如下几个优点：   1.进程之间不能共享内存，但线程之间共享内存非常容易。   2.操作系统在创建进程时，需要为该进程重新分配系统资源，但创建线程的代价则小得多。因此使用多线程来实现多任务并发执行比使用多进程的效率高   3.python语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了python的多线程编程。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。
  线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所
  拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python递归最大层数</title>
    <link href="https://www.misslegu.com/2020/08/28/Python%E9%80%92%E5%BD%92%E6%9C%80%E5%A4%A7%E5%B1%82%E6%95%B0/"/>
    <id>https://www.misslegu.com/2020/08/28/Python%E9%80%92%E5%BD%92%E6%9C%80%E5%A4%A7%E5%B1%82%E6%95%B0/</id>
    <published>2020-08-28T01:26:00.000Z</published>
    <updated>2020-08-28T01:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用sys-getrecursionlimit模块来获取递归层数"><a href="#使用sys-getrecursionlimit模块来获取递归层数" class="headerlink" title="使用sys.getrecursionlimit模块来获取递归层数"></a>使用sys.getrecursionlimit模块来获取递归层数</h2><p>from sys import getrecursionlimit # 1000</p><h2 id="设置递归层数使用sys-setrecursionlimit"><a href="#设置递归层数使用sys-setrecursionlimit" class="headerlink" title="设置递归层数使用sys.setrecursionlimit"></a>设置递归层数使用sys.setrecursionlimit</h2><p>from sys import setrecursionlimit<br>setrecursionlimit(1000)</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用sys-getrecursionlimit模块来获取递归层数&quot;&gt;&lt;a href=&quot;#使用sys-getrecursionlimit模块来获取递归层数&quot; class=&quot;headerlink&quot; title=&quot;使用sys.getrecursionlimit模块来获取递归层数&quot;&gt;&lt;/a&gt;使用sys.getrecursionlimit模块来获取递归层数&lt;/h2&gt;&lt;p&gt;from sys import getrecursionlimit # 1000&lt;/p&gt;
&lt;h2 id=&quot;设置递归层数使用sys-setrecursionlimit&quot;&gt;&lt;a href=&quot;#设置递归层数使用sys-setrecursionlimit&quot; class=&quot;headerlink&quot; title=&quot;设置递归层数使用sys.setrecursionlimit&quot;&gt;&lt;/a&gt;设置递归层数使用sys.setrecursionlimit&lt;/h2&gt;&lt;p&gt;from sys import setrecursionlimit&lt;br&gt;setrecursionlimit(1000)&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python进程的坑</title>
    <link href="https://www.misslegu.com/2020/08/25/Python%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9D%91/"/>
    <id>https://www.misslegu.com/2020/08/25/Python%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9D%91/</id>
    <published>2020-08-25T01:31:00.000Z</published>
    <updated>2020-08-25T01:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>用multiprocessing模块Process</p><p>启动一个进程用start()方法,如果没有之后没有用join的话该进程不会自动关闭会产生僵尸程序</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;用multiprocessing模块Process&lt;/p&gt;
&lt;p&gt;启动一个进程用start()方法,如果没有之后没有用join的话该进程不会自动关闭会产生僵尸程序&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python标准库、第三方和工具作用</title>
    <link href="https://www.misslegu.com/2020/08/24/Python%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%92%8C%E5%B7%A5%E5%85%B7%E4%BD%9C%E7%94%A8/"/>
    <id>https://www.misslegu.com/2020/08/24/Python%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%92%8C%E5%B7%A5%E5%85%B7%E4%BD%9C%E7%94%A8/</id>
    <published>2020-08-24T22:52:00.000Z</published>
    <updated>2020-08-24T22:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>导读：Python数据工具箱涵盖从数据源到数据可视化的完整流程中涉及到的常用库、函数和外部工具。其中既有Python内置函数和标准库，又有第三方库和工具。</p><p>这些库可用于文件读写、网络抓取和解析、数据连接、数清洗转换、数据计算和统计分析、图像和视频处理、音频处理、数据挖掘/机器学习/深度学习、数据可视化、交互学习和集成开发以及其他Python协同数据工作工具。</p><p>为了区分不同对象的来源和类型，本文将在描述中通过以下方法进行标识：</p><p>Python内置函数：Python自带的内置函数。函数无需导入，直接使用。例如要计算-3.2的绝对值，直接使用abs函数，方法是</p><a id="more"></a><p>abs(-3.2) </p><p>Python标准库：Python自带的标准库。Python标准库无需安装，只需要先通过import方法导入便可使用其中的方法。例如导入string模块，然后使用其中的find方法：</p><p>import string<br>string.find(‘abcde’,’b’)</p><p>第三方库：Python的第三方库。这些库需要先进行安装（部分可能需要配置）。</p><p>外部工具：非Python写成的库或包，用于Python数据工作的相关工具。</p><p>「推荐度」3星最高，1星最低。</p><p>01 文件读写</p><p>文件的读写包括常见的txt、Excel、xml、二进制文件以及其他格式的数据文本，主要用于本地数据的读写。</p><p>640?wx_fmt=jpeg</p><ol><li>open(name[, mode[, buffering]])</li></ol><p>类型：Python内置函数</p><p>描述：Python默认的文件读写方法</p><p>推荐度：★★★</p><ol start="2"><li>numpy.loadtxt、numpy.load和numpy.fromfile</li></ol><p>类型：第三方库</p><p>描述：Numpy自带的读写函数，包括loadtxt、load和fromfile，用于文本、二进制文件读写</p><p>推荐度：★★★</p><ol start="3"><li>pandas.read_*</li></ol><p>类型：第三方库</p><p>描述：Pandas自带的read文件方法，例如ead_csv、read_fwf、read_table等，用于文本、Excel、二进制文件、HDF5、表格、SAS文件、SQL数据库、Stata文件等的读写</p><p>推荐度：★★★</p><ol start="4"><li>xlrd</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件读取</p><p>推荐度：★★</p><ol start="5"><li>xlwt</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件写入</p><p>推荐度：★★</p><ol start="6"><li>pyexcel-xl</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件读写</p><p>推荐度：★★</p><ol start="7"><li>xluntils</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件读写</p><p>推荐度：★★</p><ol start="8"><li>pyExcelerator</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件读写</p><p>推荐度：★</p><ol start="9"><li>openpyxl</li></ol><p>类型：第三方库</p><p>描述：用于Excel文件读写</p><p>推荐度：★</p><ol start="10"><li>lxml</li></ol><p>类型：第三方库</p><p>描述：xml和HTML读取和解析</p><p>推荐度：★★★</p><ol start="11"><li>xml</li></ol><p>类型：Python标准库</p><p>描述：xml对象解析和格式化处理</p><p>推荐度：★★★</p><ol start="12"><li>libxml2</li></ol><p>类型：第三方库</p><p>描述：xml对象解析和格式化处理</p><p>推荐度：★</p><ol start="13"><li>xpath</li></ol><p>类型：第三方库</p><p>描述：xml对象解析和格式化处理</p><p>推荐度：★★</p><ol start="14"><li>win32com</li></ol><p>类型：第三方库</p><p>描述：有关Windows系统操作、Office（Word、Excel等）文件读写等的综合应用库</p><p>推荐度：★</p><p>02 网络抓取和解析</p><p>网络抓取和解析用于从互联网中抓取信息，并对HTML对象进行处理，有关xml对象的解析和处理的库在“01 文件读写”中找到。</p><p>640?wx_fmt=jpeg</p><ol start="15"><li>requests</li></ol><p>类型：第三方库</p><p>描述：网络请求库，提供多种网络请求方法并可定义复杂的发送信息</p><p>推荐度：★★★</p><ol start="16"><li>urllib</li></ol><p>类型：Python标准库</p><p>描述：Python自带的库，简单的读取特定URL并获得返回的信息</p><p>推荐度：★★</p><ol start="17"><li>urllib2</li></ol><p>类型：Python标准库</p><p>描述：Python自带的库，读取特定URL并获得返回的信息，相对于urllib可处理更多HTTP信息，例如cookie、身份验证、重定向等</p><p>推荐度：★★</p><ol start="18"><li>urlparse</li></ol><p>类型：Python标准库</p><p>描述：Python自带的URL解析库，可自动解析URL不同的域、参数、路径等</p><p>推荐度：★★★</p><ol start="19"><li>HTMLParser</li></ol><p>类型：Python标准库</p><p>描述：Python自带的HTML解析模块，能够很容易的实现HTML文件的分析</p><p>推荐度：★★★</p><ol start="20"><li>Scapy</li></ol><p>类型：第三方库</p><p>描述：分布式爬虫框架，可用于模拟用户发送、侦听和解析并伪装网络报文，常用于大型网络数据爬取</p><p>推荐度：★★★</p><ol start="21"><li>Beautiful Soup</li></ol><p>类型：第三方库</p><p>描述：Beautiful Soup是网页数据解析和格式化处理工具，通常配合Python的urllib、urllib2等库一起使用</p><p>推荐度：★★★</p><p>03 数据库连接</p><p>数据库连接可用于连接众多数据库以及访问通用数据库接口，可用于数据库维护、管理和增、删、改、查等日常操作。</p><p>640?wx_fmt=jpeg</p><ol start="22"><li>mysql-connector-python</li></ol><p>类型：第三方库</p><p>描述：MySQL官方驱动连接程序</p><p>推荐度：★★★</p><ol start="23"><li>pymysql</li></ol><p>类型：第三方库</p><p>描述：MySQL连接库，支持Python3</p><p>推荐度：★★★</p><ol start="24"><li>MySQL-python</li></ol><p>类型：第三方库</p><p>描述：MySQL连接库</p><p>推荐度：★★</p><ol start="25"><li>cx_Oracle</li></ol><p>类型：第三方库</p><p>描述：Oracle连接库</p><p>推荐度：★★★</p><ol start="26"><li>psycopg2</li></ol><p>类型：第三方库</p><p>描述：Python编程语言中非常受欢迎的PostgreSQL适配器</p><p>推荐度：★★★</p><ol start="27"><li>redis</li></ol><p>类型：Python标准库</p><p>描述：Redis连接库</p><p>推荐度：★★★</p><ol start="28"><li>pymongo</li></ol><p>类型：第三方库</p><p>描述：MongoDB官方驱动连接程序</p><p>推荐度：★★★</p><ol start="29"><li>HappyBase</li></ol><p>类型：第三方库</p><p>描述：HBase连接库</p><p>推荐度：★★★</p><ol start="30"><li>py2neo</li></ol><p>类型：第三方库</p><p>描述：Neo4j连接库</p><p>推荐度：★★★</p><ol start="31"><li>cassandra-driver</li></ol><p>类型：第三方库</p><p>描述：Cassandra（1.2+）和DataStax Enterprise（3.1+）连接库</p><p>推荐度：★★★</p><ol start="32"><li>sqlite3</li></ol><p>类型：Python标准库</p><p>描述：Python自带的模块，用于操作SQLite数据库</p><p>推荐度：★★★</p><ol start="33"><li>pysqlite2</li></ol><p>类型：第三方库</p><p>描述：SQLite 3.x连接库</p><p>推荐度：★★</p><ol start="34"><li>bsddb3</li></ol><p>类型：第三方库</p><p>描述：Berkeley DB连接库</p><ol start="35"><li>bsddb</li></ol><p>类型：Python标准库</p><p>描述：Python自带的模块，提供了一个到Berkeley DB库的接口</p><p>推荐度：★★</p><ol start="36"><li>dbhash</li></ol><p>类型：Python标准库</p><p>描述：Python自带的模块，dbhash模块提供了使用BSD数据库库打开数据库的功能。该模块镜像了提供对DBM样式数据库访问的其他Python数据库模块的接口。bsddb模块需要使用dbhash</p><p>推荐度：★★</p><ol start="37"><li>adodb</li></ol><p>类型：第三方库</p><p>描述：ADOdb是一个数据库抽象库，支持常见的数据和数据库接口并可自行进行数据库扩展，该库可以对不同数据库中的语法进行解析和差异化处理，具有很高的通用性</p><p>推荐度：★★★</p><ol start="38"><li>SQLObject</li></ol><p>类型：第三方库</p><p>描述：SQLObject是一种流行的对象关系管理器，用于向数据库提供对象接口，其中表为类、行为实例、列为属性</p><p>推荐度：★★</p><ol start="39"><li>SQLAlchemy</li></ol><p>类型：第三方库</p><p>描述：SQLAlchemy是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性控制</p><p>推荐度：★★</p><ol start="40"><li>ctypes</li></ol><p>类型：第三方库</p><p>描述：ctypes是Python的一个外部库，提供和C语言兼容的数据类型，可以很方便地调用C DLL中的函数</p><p>推荐度：★★★</p><ol start="41"><li>pyodbc</li></ol><p>类型：第三方库</p><p>描述：Python通过ODBC访问数据库的接口库</p><p>推荐度：★★★</p><ol start="42"><li>Jython</li></ol><p>类型：第三方库</p><p>描述：Python通过JDBC访问数据库的接口库</p><p>推荐度：★★★</p><p>04 数据清洗转换</p><p>数据清洗转换主用于数据正式应用之前的预处理工作。</p><p>640?wx_fmt=jpeg</p><ol start="43"><li>frozenset([iterable])</li></ol><p>类型：Python内置函数</p><p>描述：返回一个新的frozenset对象，可选择从iterable取得的元素</p><p>推荐度：★★★</p><ol start="44"><li>int(x)</li></ol><p>类型：Python内置函数</p><p>描述：返回x的整数部分</p><p>推荐度：★★★</p><ol start="45"><li>isinstance(object, classinfo)</li></ol><p>类型：Python内置函数</p><p>描述：返回object是否是指定的classinfo实例信息</p><p>推荐度：★★★</p><ol start="46"><li>len(s)</li></ol><p>类型：Python内置函数</p><p>描述：返回对象的长度或项目数量</p><p>推荐度：★★★</p><ol start="47"><li>long(x)</li></ol><p>类型：Python内置函数</p><p>描述：返回由字符串或数字x构造的长整型对象</p><p>推荐度：★★★</p><ol start="48"><li>max(iterable[, key])</li></ol><p>类型：Python内置函数</p><p>描述：返回一个可迭代或最大的两个或多个参数中的最大项</p><p>推荐度：★★★</p><ol start="49"><li>min(iterable[, key])</li></ol><p>类型：Python内置函数</p><p>描述：返回一个可迭代或最大的两个或多个参数中的最小项</p><p>推荐度：★★★</p><ol start="50"><li>range(start, stop[, step])</li></ol><p>类型：Python内置函数</p><p>描述：用于与for循环一起创建循环列表，通过指定start（开始）、stop（结束）和step（步长）控制迭代次数并获取循环值</p><p>推荐度：★★★</p><ol start="51"><li>raw_input(prompt)</li></ol><p>类型：Python内置函数</p><p>描述：捕获用户输入并作为字符串返回（不推荐使用input作为用户输入的捕获函数）</p><p>推荐度：★★★</p><ol start="52"><li>round(number[, ndigits])</li></ol><p>类型：Python内置函数</p><p>描述：返回number小数点后ndigits位的四舍五入的浮点数</p><p>推荐度：★★★</p><ol start="53"><li>set([iterable])</li></ol><p>类型：Python内置函数</p><p>描述：返回一个新的集合对象，可选择从iterable获取的元素</p><p>推荐度：★★★</p><ol start="54"><li>slice(start, stop[, step])</li></ol><p>类型：Python内置函数</p><p>描述：返回表示由范围（start、stop、step）指定的索引集的切片对象</p><p>推荐度：★★</p><ol start="55"><li>sorted(iterable[, cmp[, key[, reverse]]])</li></ol><p>类型：Python内置函数</p><p>描述：从iterable的项中返回一个新的排序列表</p><p>推荐度：★★★</p><ol start="56"><li>xrange(start, stop[, step])</li></ol><p>类型：Python内置函数</p><p>描述：此函数与range()非常相似，但返回一个xrange对象而不是列表</p><p>推荐度：★★★</p><ol start="57"><li>string</li></ol><p>类型：Python标准库</p><p>描述：字符串处理库，可实现字符串查找、分割、组合、替换、去重、大小写转换及其他格式化处理</p><p>推荐度：★★★</p><ol start="58"><li>re</li></ol><p>类型：Python标准库</p><p>描述：正则表达式模块，在文本和字符串处理中经常使用</p><p>推荐度：★★★</p><ol start="59"><li>random</li></ol><p>类型：Python标准库</p><p>描述：该模块为各种分布实现伪随机数生成器，支持数据均匀分布、正态（高斯）分布、对数正态分布、负指数分布、伽马和β分布等</p><p>推荐度：★★★</p><ol start="60"><li>os</li></ol><p>类型：Python标准库</p><p>描述：用于新建、删除、权限修改、切换路径等目录操作，以及调用执行系统命令</p><p>推荐度：★★★</p><ol start="61"><li>os.path</li></ol><p>类型：Python标准库</p><p>描述：针对目录的遍历、组合、分割、判断等操作，常用于数据文件的判断、查找、合并</p><p>推荐度：★★★</p><ol start="62"><li>prettytable</li></ol><p>类型：Python标准库</p><p>描述：格式化表格输出模块</p><p>推荐度：★★</p><ol start="63"><li>json</li></ol><p>类型：Python标准库</p><p>描述：Python对象与json对象的转换</p><p>推荐度：★★★</p><ol start="64"><li>base64</li></ol><p>类型：Python标准库</p><p>描述：将任意二进制字符串编码和解码为文本字符串的Base16，Base32和Base64</p><p>推荐度：★★★</p><p>05 数据计算和统计分析</p><p>数据计算和统计分析主要用于数据探查、计算和初步数据分析等工作。</p><p>640?wx_fmt=jpeg</p><ol start="65"><li>numpy</li></ol><p>类型：第三方库</p><p>描述：NumPy是Python科学计算的基础工具包，很多Python数据计算工作库都依赖它</p><p>推荐度：★★★</p><ol start="66"><li>scipy</li></ol><p>类型：第三方库</p><p>描述：Scipy是一组专门解决科学和工程计算不同场景的主题工具包</p><p>推荐度：★★★</p><ol start="67"><li>pandas</li></ol><p>类型：第三方库</p><p>描述：Pandas是一个用于Python数据分析的库，它的主要作用是进行数据分析。Pandas提供用于进行结构化数据分析的二维的表格型数据结构DataFrame，类似于R中的数据框，能提供类似于数据库中的切片、切块、聚合、选择子集等精细化操作，为数据分析提供了便捷</p><p>推荐度：★★★</p><ol start="68"><li>statsmodels</li></ol><p>类型：第三方库</p><p>描述：Statsmodels是Python的统计建模和计量经济学工具包，包括一些描述性统计、统计模型估计和统计测试，集成了多种线性回归模型、广义线性回归模型、离散数据分布模型、时间序列分析模型、非参数估计、生存分析、主成分分析、核密度估计以及广泛的统计测试和绘图等功能</p><p>推荐度：★★★</p><ol start="69"><li>abs(x)</li></ol><p>类型：Python内置函数</p><p>描述：返回x的绝对值</p><p>推荐度：★★★</p><ol start="70"><li>cmp(x, y)</li></ol><p>类型：Python内置函数</p><p>描述：比较两个对象x和y，并根据结果返回一个整数。如果x &lt;y，则返回值为负数，如果x == y则为零，如果x&gt; y则返回值为正</p><p>推荐度：★★</p><ol start="71"><li>float(x)</li></ol><p>类型：Python内置函数</p><p>描述：返回从数字或字符串x构造的浮点数</p><p>推荐度：★★★</p><ol start="72"><li>pow(x, y[, z])</li></ol><p>类型：Python内置函数</p><p>描述：返回x的y次幂。如果z存在，则返回x的y次幂，模z</p><p>推荐度：★★★</p><ol start="73"><li>sum(iterable[, start])</li></ol><p>类型：Python内置函数</p><p>描述：从左到右依次迭代，返回总和</p><p>推荐度：★★★</p><ol start="74"><li>math</li></ol><p>类型：Python标准库</p><p>描述：数学函数库，包括正弦、余弦、正切、余切、弧度转换、对数运算、圆周率、绝对值、取整等数学计算方法</p><p>推荐度：★★★</p><ol start="75"><li>cmath</li></ol><p>类型：Python标准库</p><p>描述：与math基本一致，区别是cmath运算的是复数</p><p>推荐度：★★</p><ol start="76"><li>decimal</li></ol><p>类型：Python标准库</p><p>描述：10进制浮点运算</p><p>推荐度：★★</p><ol start="77"><li>fractions</li></ol><p>类型：Python标准库</p><p>描述：分数模块提供对有理数算术的支持</p><p>推荐度：★★</p><p>06 自然语言处理和文本挖掘</p><p>自然语言处理和文本挖掘库主要用于以自然语言文本为对象的数据处理和建模。</p><p>640?wx_fmt=jpeg</p><ol start="78"><li>nltk</li></ol><p>类型：第三方库</p><p>描述：NLTK是一个Python自然语言处理工具，它用于对自然语言进行分类、解析和语义理解。目前已经有超过50种语料库和词汇资源</p><p>推荐度：★★★</p><ol start="79"><li>pattern</li></ol><p>类型：第三方库</p><p>描述：Pattern是一个网络数据挖掘Python工具包，提供了用于网络挖掘（如网络服务、网络爬虫等）、自然语言处理（如词性标注、情感分析等）、机器学习（如向量空间模型、分类模型等）、图形化的网络分析模型</p><p>推荐度：★★★</p><ol start="80"><li>gensim</li></ol><p>类型：第三方库</p><p>描述：Gensim是一个专业的主题模型（发掘文字中隐含主题的一种统计建模方法）Python工具包，用来提供可扩展统计语义、分析纯文本语义结构以及检索语义上相似的文档</p><p>推荐度：★★★</p><ol start="81"><li>结巴分词</li></ol><p>类型：第三方库</p><p>描述：结巴分词是国内流行的Python文本处理工具包，分词模式分为三种模式：精确模式、全模式和搜索引擎模式，支持繁体分词、自定义词典等，是非常好的Python中文分词解决方案，可以实现分词、词典管理、关键字抽取、词性标注等</p><p>推荐度：★★★</p><ol start="82"><li>SnowNLP</li></ol><p>类型：第三方库</p><p>描述：SnowNLP是一个Python写的类库，可以方便的处理中文文本内容。该库是受到了TextBlob的启发而针对中文处理写的类库，和TextBlob不同的是这里没有用NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典</p><p>推荐度：★★</p><ol start="83"><li>smallseg</li></ol><p>类型：第三方库</p><p>描述：Smallseg是一个开源的、基于DFA的轻量级的中文分词工具包。可自定义词典、切割后返回登录词列表和未登录词列表、有一定的新词识别能力</p><p>推荐度：★★</p><ol start="84"><li>spaCy</li></ol><p>类型：第三方库</p><p>描述：spaCy是一个Python自然语言处理工具包，它结合Python和Cython使得自然语言处理能力达到了工业强度</p><p>推荐度：★★★</p><ol start="85"><li>TextBlob</li></ol><p>类型：第三方库</p><p>描述：TextBlob 是一个处理文本数据的Python库，可用来做词性标注、情感分析、文本翻译、名词短语抽取、文本分类等</p><p>推荐度：★★</p><ol start="86"><li>PyNLPI</li></ol><p>类型：第三方库</p><p>描述：PyNLPI是一个适合各种自然语言处理任务的集合库，可用于中文文本分词、关键字分析等，尤其重要的是其支持中英文映射，支持UTF-8和GBK编码的字符串等</p><p>推荐度：★★★</p><ol start="87"><li>synonyms</li></ol><p>类型：第三方库</p><p>描述：中文近义词工具包，可用于自然语言理解的很多任务：文本对齐，推荐算法，相似度计算，语义偏移，关键字提取，概念提取，自动摘要，搜索引擎等。</p><p>推荐度：★★★</p><p>07 图像和视频处理</p><p>图像处理和视频处理主要适用于基于图像的操作、处理、分析和挖掘，如人脸识别、图像识别、目标跟踪、图像理解等。</p><p>640?wx_fmt=jpeg</p><ol start="88"><li>PIL/Pillow</li></ol><p>类型：第三方库</p><p>描述：PIL是一个常用的图像读取、处理和分析的库，提供了多种数据处理、变换的操作方法和属性。PIL仅支持到2.7版本且已经很久没有更新，一群志愿者基于PIL发布了新的分支Pillow。Pillow同时支持Python2和Python3并且加入很多新的功能</p><p>推荐度：★★</p><ol start="89"><li>OpenCV</li></ol><p>类型：第三方库</p><p>描述：OpenCV是一个强大的图像和视频工作库。它提供了多种程序接口，支持跨平台（包括移动端）应用。OpenCV的设计效率很高，它以优化的C / C ++编写，库可以利用多核处理。除了对图像进行基本处理外，还支持图像数据建模，并预制了多种图像识别引擎，如人脸识别</p><p>推荐度：★★★</p><ol start="90"><li>scikit-image</li></ol><p>类型：第三方库</p><p>描述：scikit-image（也称skimage）是一个图像处理库，支持颜色模式转换、滤镜、绘图、图像处理、特征检测等多种功能</p><p>推荐度：★★</p><ol start="91"><li>imageop</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，对图像基本操作，包括裁剪、缩放、模式转换</p><p>推荐度：★</p><ol start="92"><li>colorsys</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，实现不同图像色彩模式的转换</p><p>推荐度：★</p><ol start="93"><li>imghdr</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，返回图像文件的类型</p><p>推荐度：★</p><p>08 音频处理</p><p>音频处理主要适用于基于声音的处理、分析和建模，主要应用于语音识别、语音合成、语义理解等。</p><p>640?wx_fmt=jpeg</p><ol start="94"><li>TimeSide</li></ol><p>类型：第三方库</p><p>描述：TimeSide是一个能够进行音频分析、成像、转码、流媒体和标签处理的Python框架，可以对任何音频或视频内容非常大的数据集进行复杂的处理</p><p>推荐度：★★★</p><ol start="95"><li>audiolazy</li></ol><p>类型：第三方库</p><p>描述：audiolazy是一个用于实时声音数据流处理的库，支持实时数据应用处理、无限数据序列表示、数据流表示等</p><p>推荐度：★★</p><ol start="96"><li>pydub</li></ol><p>类型：第三方库</p><p>描述：pydub支持多种格式声音文件，可进行多种信号处理（例如压缩、均衡、归一化）、信号生成（例如正弦、方波、锯齿等）、音效注册、静音处理等</p><p>推荐度：★★★</p><ol start="97"><li>audioop</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，可实现对声音片段的一些常用操作</p><p>推荐度：★★</p><ol start="98"><li>tinytag</li></ol><p>类型：第三方库</p><p>描述：tinytag用于读取多种声音文件的元数据，涵盖MP3、OGG、OPUS、MP4、M4A、FLAC、WMA、Wave等格式</p><p>推荐度：★★</p><ol start="99"><li>aifc</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，读写AIFF和AIFC文件</p><p>推荐度：★</p><ol start="100"><li>sunau</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，读写Sun AU文件</p><p>推荐度：★</p><ol start="101"><li>wave</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，读写WAV文件</p><p>推荐度：★★</p><ol start="102"><li>chunk</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，读取EA IFF 85块格式的文件</p><p>推荐度：★</p><ol start="103"><li>sndhdr</li></ol><p>类型：Python标准库</p><p>描述：Python自带的函数，返回声音文件的类型</p><p>推荐度：★</p><ol start="104"><li>ossaudiodev</li></ol><p>类型：Python标准库</p><p>描述：该模块支持访问OSS（开放声音系统）音频接口</p><p>推荐度：★★★</p><p>09 数据挖掘/机器学习/深度学习</p><p>数据挖掘、机器学习和深度学习等是Python进行数据建模和挖掘学习的核心模块。</p><p>640?wx_fmt=jpeg</p><ol start="105"><li>Scikit-Learn</li></ol><p>类型：第三方库</p><p>描述：scikit-learn（也称SKlearn）是一个基于Python的机器学习综合库，内置监督式学习和非监督式学习机器学习方法，包括各种回归、聚类、分类、流式学习、异常检测、神经网络、集成方法等主流算法类别，同时支持预置数据集、数据预处理、模型选择和评估等方法，是一个非常完整、流行的机器学习工具库</p><p>推荐度：★★★</p><ol start="106"><li>TensorFlow</li></ol><p>类型：第三方库</p><p>描述：TensorFlow 是谷歌的第二代机器学习系统，内建深度学习的扩展支持，任何能够用计算流图形来表达的计算，都可以使用 TensorFlow</p><p>推荐度：★★★</p><ol start="107"><li>NuPIC</li></ol><p>类型：第三方库</p><p>描述：NuPIC是一个以HTM（分层时间记忆）学习算法为工具的机器智能平台。NuPIC适合于各种各样的问题，尤其适用于检测异常和预测应用</p><p>推荐度：★★★</p><ol start="108"><li>PyTorch</li></ol><p>类型：第三方库</p><p>描述：PyTorch是FaceBook推出的深度学习框架，它基于Python（而非lua）产生，它提供的动态计算图是显著区别于Tensorflow等其他学习框架的地方。</p><p>推荐度：★★</p><ol start="109"><li>Orange</li></ol><p>类型：第三方库</p><p>描述：Orange通过图形化操作界面，提供交互式数据分析功能，尤其适用于分类、聚类、回归、特征选择和交叉验证工作</p><p>推荐度：★★★</p><ol start="110"><li>theano</li></ol><p>类型：第三方库</p><p>描述：Theano是非常成熟的深度学习库。它与Numpy紧密集成，支持GPU计算、单元测试和自我验证</p><p>推荐度：★★★</p><ol start="111"><li>keras</li></ol><p>类型：第三方库</p><p>描述：Keras是一个用Python编写的高级神经网络API，能够运行在TensorFlow或者Theano之上，它的开发重点是实现快速实验</p><p>推荐度：★★</p><ol start="112"><li>neurolab</li></ol><p>类型：第三方库</p><p>描述：Neurolab是具有灵活网络配置和Python学习算法的基本神经网络算法库。它包含通过递归神经网络（RNN）实现的不同变体，该库是同类RNN API中最好的选择之一</p><p>推荐度：★★</p><ol start="113"><li>PyLearn2</li></ol><p>类型：第三方库</p><p>描述：PyLearn2是基于Theano的深度学习库，它旨在提供极大的灵活性，并使研究人员可以进行自由可控制，参数和属性的灵活、开放配置是亮点</p><p>推荐度：★★★</p><ol start="114"><li>OverFeat</li></ol><p>类型：第三方库</p><p>描述：OverFeat是一个深度学习库，主要用于图片分类、定位物体检测</p><p>推荐度：★★</p><ol start="115"><li>Pyevolve</li></ol><p>类型：第三方库</p><p>描述：Pyevolve是一个完整的遗传算法框架，也支持遗传编程</p><p>推荐度：★★</p><ol start="116"><li>Caffe2</li></ol><p>类型：第三方库</p><p>描述：Cafffe2也是FaceBook推出的深度学习框架，相比于PyTorch 更适合于研究，Caffe2 适合大规模部署，主要用于计算机视觉，它对图像识别的分类具有很好的应用效果</p><p>推荐度：★★</p><p>10 数据可视化</p><p>数据可视化主要用于做数据结果展示、数据模型验证、图形交互和探查等方面。</p><p>640?wx_fmt=jpeg</p><ol start="117"><li>Matplotlib</li></ol><p>类型：第三方库</p><p>描述：Matplotlib是Python的2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形，开发者可以仅需要几行代码，便可以生成多种高质量图形</p><p>推荐度：★★★</p><ol start="118"><li>pyecharts</li></ol><p>类型：第三方库</p><p>描述：基于百度Echarts的强大的可视化工具库，其提供的图形功能众多，尤其对于复杂关系的展示能力较强</p><p>推荐度：★★★</p><ol start="119"><li>seaborn</li></ol><p>类型：第三方库</p><p>描述：Seaborn是在Matplotlib的基础上进行了更高级的API封装，它可以作为Matplotlib的补充</p><p>推荐度：★★★</p><ol start="120"><li>bokeh</li></ol><p>类型：第三方库</p><p>描述：Bokeh是一种交互式可视化库，可以在WEB浏览器中实现美观的视觉效果</p><p>推荐度：★★★</p><ol start="121"><li>Plotly</li></ol><p>类型：第三方库</p><p>描述：Plotly提供的图形库可以进行在线WEB交互，并提供具有出版品质的图形，支持线图、散点图、区域图、条形图、误差条、框图、直方图、热图、子图、多轴、极坐标图、气泡图、玫瑰图、热力图、漏斗图等众多图形</p><p>推荐度：★★★</p><ol start="122"><li>VisPy</li></ol><p>类型：第三方库</p><p>描述：VisPy是用于交互式科学可视化的Python库，旨在实现快速，可扩展和易于使用</p><p>推荐度：★★</p><ol start="123"><li>PyQtGraph</li></ol><p>类型：第三方库</p><p>描述：PyQtGraph是一个建立在PyQt4 / PySide和numpy之上的纯Python图形和GUI库，主要用于数学/科学/工程应用</p><p>推荐度：★★</p><ol start="124"><li>ggplot</li></ol><p>类型：第三方库</p><p>描述：ggplot是用Python实现的图形输出库，类似于 R中的图形展示版本</p><p>推荐度：★★★</p><p>11 交互学习和集成开发</p><p>交互学习和集成开发主要用来做Python开发、调试和集成之用，包括Python集成开发环境和IDE。</p><p>640?wx_fmt=jpeg</p><ol start="125"><li>IPython/ Jupyter</li></ol><p>类型：第三方库</p><p>描述：IPython 是一个基于Python 的交互式shell，比默认的Python shell 好用得多，支持变量自动补全、自动缩进、交互式帮助、魔法命令、系统命令等，内置了许多很有用的功能和函数。从IPython4.0开始，IPython衍生出了IPython和Jupyter两个分支。在该分支正式出现之前，IPython其实已经拥有了ipython notebook功能，因此，Jupyter更像是一个ipython notebook的升级版。</p><p>推荐度：★★★</p><ol start="126"><li>Elpy</li></ol><p>类型：第三方库</p><p>描述：Elpy是Emacs用于Python的开发环境，它结合并配置了许多其他软件包，它们都是用Emacs Lisp和Python编写的</p><p>推荐度：★★</p><ol start="127"><li>PTVS</li></ol><p>类型：第三方库</p><p>描述：Visual Studio 的 Python 工具</p><p>推荐度：★★</p><ol start="128"><li>PyCharm</li></ol><p>类型：外部工具</p><p>描述：PyCharm带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制并可集成IPython、系统终端命令行等，在PyCharm里几乎就可以实现所有有关Python工作的全部过程</p><p>推荐度：★★★</p><ol start="129"><li>LiClipse</li></ol><p>类型：外部工具</p><p>描述：LiClipse是基于Eclipse的免费多语言 IDE，通过其中的PyDev可支持 Python开发应用</p><p>推荐度：★★</p><ol start="130"><li>Spyder</li></ol><p>类型：外部工具</p><p>描述：Spyder是一个开源的Python IDE，由IPython和众多流行的Python库的支持，是一个具备高级编辑、交互式测试、调试以及数字计算环境的交互式开发环境</p><p>推荐度：★★</p><p>12 其他Python协同数据工作工具</p><p>其他Python协同数据工作工具指除了上述主题以外，其他在数据工作中常用的工具或库。</p><ol start="131"><li>tesseract-ocr</li></ol><p>类型：外部工具</p><p>描述：这是一个Google支持的开源OCR图文识别项目，支持超过200种语言（包括中文），并支持自定义训练字符集，支持跨Windows、Linux、Mac OSX 多平台使用</p><p>推荐度：★★★</p><ol start="132"><li>RPython</li></ol><p>类型：第三方库</p><p>描述：R集成库</p><p>推荐度：★★★</p><ol start="133"><li>Rpy2</li></ol><p>类型：第三方库</p><p>描述：Python连接R的库</p><ol start="134"><li>matpython</li></ol><p>类型：第三方库</p><p>描述：MATLAB集成库</p><p>推荐度：★★★</p><ol start="135"><li>Lunatic Python</li></ol><p>类型：第三方库</p><p>描述：Lua集成库</p><p>推荐度：★★</p><ol start="136"><li>PyCall.jl</li></ol><p>类型：第三方库</p><p>描述：Julia集成库</p><p>推荐度：★★</p><ol start="137"><li>PySpark</li></ol><p>类型：第三方库</p><p>描述：Spark提供的Python API</p><p>推荐度：★★★</p><ol start="138"><li>dumbo</li></ol><p>类型：第三方库</p><p>描述：这个模块可以让Pythoner轻松的编写和运行 Hadoop 程序，程序版本比较早，可以作为参考</p><p>推荐度：★★</p><ol start="139"><li>dpark</li></ol><p>类型：第三方库</p><p>描述：Python对Spark的克隆版本，类MapReduce框架</p><p>推荐度：★★</p><ol start="140"><li>streamparse</li></ol><p>类型：第三方库</p><p>描述：Streamparse允许通过Storm对实时数据流运行Python代码</p><p>推荐度：★★★</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;导读：Python数据工具箱涵盖从数据源到数据可视化的完整流程中涉及到的常用库、函数和外部工具。其中既有Python内置函数和标准库，又有第三方库和工具。&lt;/p&gt;
&lt;p&gt;这些库可用于文件读写、网络抓取和解析、数据连接、数清洗转换、数据计算和统计分析、图像和视频处理、音频处理、数据挖掘/机器学习/深度学习、数据可视化、交互学习和集成开发以及其他Python协同数据工作工具。&lt;/p&gt;
&lt;p&gt;为了区分不同对象的来源和类型，本文将在描述中通过以下方法进行标识：&lt;/p&gt;
&lt;p&gt;Python内置函数：Python自带的内置函数。函数无需导入，直接使用。例如要计算-3.2的绝对值，直接使用abs函数，方法是&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.misslegu.com/categories/python/"/>
    
    
    <category term="python" scheme="https://www.misslegu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python学习:列表list</title>
    <link href="https://www.misslegu.com/2020/08/24/python%E5%AD%A6%E4%B9%A0-%E5%88%97%E8%A1%A8list/"/>
    <id>https://www.misslegu.com/2020/08/24/python%E5%AD%A6%E4%B9%A0-%E5%88%97%E8%A1%A8list/</id>
    <published>2020-08-24T08:22:00.000Z</published>
    <updated>2020-08-24T08:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="list内置函数使用"><a href="#list内置函数使用" class="headerlink" title="list内置函数使用"></a>list内置函数使用</h3><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.pop() <span class="comment"># 默认弹出索引-1(最后一个值)并返回值</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.clear() <span class="comment"># 原地清空list,返回None</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.remove(<span class="number">1</span>) <span class="comment"># 需要填写1个参数,原地删除指定值,返回None</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.index(<span class="number">1</span>) <span class="comment"># 需要输入一个值,来判断当前值在list中索引位置</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">l.sort() <span class="comment"># 按小到大的顺序排序,就地修改,返回None</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.reverse() <span class="comment"># 将当前list倒排,就地修改,返回None</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 需要填写两个参数,第一个为索引地址, 第二个是要插入的值,用于插入数据.就地修改,返回None</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l.append(<span class="number">5</span>) <span class="comment"># 需要填写一个参数,该参数是要追加的内容.就地修改,返回None</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">l2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l1.extend(l2) <span class="comment"># 该参数必须是iteration,将两个list合并跟(l1 + l2)相似.extend就地修改,两个list相加则返回新的list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l.count(<span class="number">1</span>) <span class="comment"># 这个查数用于统计list中出次数,不在这个list则返回0</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = l1.copy() <span class="comment"># 用于copy一个list,会返回一个新的list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;list内置函数使用&quot;&gt;&lt;a href=&quot;#list内置函数使用&quot; class=&quot;headerlink&quot; title=&quot;list内置函数使用&quot;&gt;&lt;/a&gt;list内置函数使用&lt;/h3&gt;&lt;h4 id=&quot;pop&quot;&gt;&lt;a href=&quot;#pop&quot; class=&quot;headerlink&quot; title=&quot;pop&quot;&gt;&lt;/a&gt;pop&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;l = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;l.pop() &lt;span class=&quot;comment&quot;&gt;# 默认弹出索引-1(最后一个值)并返回值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;clear&quot;&gt;&lt;a href=&quot;#clear&quot; class=&quot;headerlink&quot; title=&quot;clear&quot;&gt;&lt;/a&gt;clear&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;l = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;l.clear() &lt;span class=&quot;comment&quot;&gt;# 原地清空list,返回None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="list" scheme="https://www.misslegu.com/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>阿里云ECS无法访问</title>
    <link href="https://www.misslegu.com/2020/05/06/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/"/>
    <id>https://www.misslegu.com/2020/05/06/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</id>
    <published>2020-05-06T10:45:00.000Z</published>
    <updated>2020-05-06T10:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NET原因"><a href="#NET原因" class="headerlink" title="NET原因"></a>NET原因</h2><p>因为公司网络是通过net转发出去的,多请求是源ip导致无法访问到web服务</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在ecs服务器上/etc/sysctl.conf中增加</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">net</span>.ipv<span class="number">4</span>.tcp_tw_recycle=<span class="number">0</span></span><br><span class="line"><span class="attribute">net</span>.ipv<span class="number">4</span>.tcp_timestamps=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后使用sysctl -p</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;NET原因&quot;&gt;&lt;a href=&quot;#NET原因&quot; class=&quot;headerlink&quot; title=&quot;NET原因&quot;&gt;&lt;/a&gt;NET原因&lt;/h2&gt;&lt;p&gt;因为公司网络是通过net转发出去的,多请求是源ip导致无法访问到web服务&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术" scheme="https://www.misslegu.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>记录:gitlab修改域名</title>
    <link href="https://www.misslegu.com/2020/04/27/%E8%AE%B0%E5%BD%95-gitlab%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D/"/>
    <id>https://www.misslegu.com/2020/04/27/%E8%AE%B0%E5%BD%95-gitlab%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D/</id>
    <published>2020-04-27T08:51:00.000Z</published>
    <updated>2020-04-27T08:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近对gitlab服务器进行了迁移,迁移之后原有的域名不用了.所以我这里做了下记录</p><a id="more"></a><p>1.首先我们要gitlab的配置文件进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改host字段,如果你的端口不是80的话可以修改掉</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitlab:</span></span><br><span class="line">  <span class="comment">## Web server settings (<span class="doctag">note:</span> host is the FQDN, do not include http://)</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">xxxxxxxxx.com</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">https:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.我们在修改nginx中gitlab-http.conf配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/var/</span>opt<span class="regexp">/gitlab/</span>nginx<span class="regexp">/conf/gi</span>tlab-http.conf </span><br><span class="line">将server_name的参数改掉就可以了</span><br></pre></td></tr></table></figure><p>3.重启gitlab跟nginx就可以了(当然我这里用的容器所以只需要重启容器就可以了)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近对gitlab服务器进行了迁移,迁移之后原有的域名不用了.所以我这里做了下记录&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="gitlab" scheme="https://www.misslegu.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>docker时间与宿主机不一致</title>
    <link href="https://www.misslegu.com/2020/04/27/docker%E6%97%B6%E9%97%B4%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>https://www.misslegu.com/2020/04/27/docker%E6%97%B6%E9%97%B4%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-04-27T08:32:00.000Z</published>
    <updated>2020-04-27T08:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检测时间"><a href="#检测时间" class="headerlink" title="检测时间"></a>检测时间</h2><p>1.首先看宿主机时间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">date</span></span><br><span class="line"><span class="selector-tag">Mon</span> <span class="selector-tag">Apr</span> 27 16<span class="selector-pseudo">:33</span><span class="selector-pseudo">:13</span> <span class="selector-tag">CST</span> 2020</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><p>2.在看容器时间</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@a9444253b914</span><span class="symbol">:/usr/local/tomcat</span><span class="comment"># date</span></span><br><span class="line">Mon Apr <span class="number">27</span> 08<span class="symbol">:</span><span class="number">36</span><span class="symbol">:</span><span class="number">30</span> UTC <span class="number">2020</span></span><br></pre></td></tr></table></figure><p>这里我们可以看出容器的时间跟宿主机不在一个时间</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1.我们可以将宿主的localtime文件copy到container id中替换掉</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker cp <span class="regexp">/etc/</span>localtime 容器ID:<span class="regexp">/etc/</span>localtime</span><br><span class="line">[root@localhost appdatas]<span class="comment"># docker cp /etc/localtime cat:/etc/localtime </span></span><br><span class="line"></span><br><span class="line">Error response from daemon: Error processing tar file(<span class="keyword">exit</span> status <span class="number">1</span>): invalid symlink <span class="string">&quot;/usr/share/zoneinfo/UCT&quot;</span> -&gt; <span class="string">&quot;../usr/share/zoneinfo/Asia/Shanghai&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps:因为软连接的问题导致这里报错<br>我们可以将宿主机的配置文件到其他地方(不保存原有的连接属性)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>localtime ./</span><br></pre></td></tr></table></figure><p>2.我们这时候在看下容器时间</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@a9444253b914</span><span class="symbol">:/usr/local/tomcat</span><span class="comment"># date</span></span><br><span class="line">Mon Apr <span class="number">27</span> <span class="number">16</span><span class="symbol">:</span><span class="number">48</span><span class="symbol">:</span><span class="number">23</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure><!--more--><h2 id="容器时间的坑"><a href="#容器时间的坑" class="headerlink" title="容器时间的坑"></a>容器时间的坑</h2><p>1.有时候我们程序需要打印日志,会发现容器的时间跟宿主时间是一致但是输出的日志时间有问题<br>2.解决方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Asia/Shanghai &gt; <span class="regexp">/etc/</span>timezone</span><br></pre></td></tr></table></figure><p>3.这时候我们需要重启下容器,然后检查日志.这时候我们的日志时间就正常了</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;检测时间&quot;&gt;&lt;a href=&quot;#检测时间&quot; class=&quot;headerlink&quot; title=&quot;检测时间&quot;&gt;&lt;/a&gt;检测时间&lt;/h2&gt;&lt;p&gt;1.首先看宿主机时间&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[root@localhost ~]&lt;/span&gt;# &lt;span class=&quot;selector-tag&quot;&gt;date&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;Mon&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;Apr&lt;/span&gt; 27 16&lt;span class=&quot;selector-pseudo&quot;&gt;:33&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:13&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;CST&lt;/span&gt; 2020&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://www.misslegu.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>记录: gitlab迁移</title>
    <link href="https://www.misslegu.com/2020/04/23/%E8%AE%B0%E5%BD%95-gitlab%E8%BF%81%E7%A7%BB/"/>
    <id>https://www.misslegu.com/2020/04/23/%E8%AE%B0%E5%BD%95-gitlab%E8%BF%81%E7%A7%BB/</id>
    <published>2020-04-23T09:06:00.000Z</published>
    <updated>2020-04-23T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我司原有的gitlab仓库运行时间久了,加上机器快到期.刚好可以更换服务器</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>1.对原有的容器进行备份,/etc/gitlab放置了gitlab的配置文件,这个很重要不然后你后面恢复会找不到项目仓库的.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 docker cp 容器ID:/etc/gitlab ./</span><br><span class="line"><span class="comment">#将容器中gitlab配置目录copy到本地</span></span><br></pre></td></tr></table></figure><p>2.我们进入到容器中创建备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器ID /bin/bash</span><br><span class="line"><span class="built_in">cd</span> /var/opt/gitlab/backups</span><br><span class="line">gitlab-rake gitlab:backup:create</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.现在需要启动新的容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p -c2 -m8G <span class="number">2222</span>:<span class="number">22</span> -p <span class="number">8888</span>:<span class="number">80</span> -v <span class="regexp">/data/gi</span>tlab<span class="regexp">/backups:/</span>var<span class="regexp">/opt/gi</span>tlab<span class="regexp">/backups -v /</span>data<span class="regexp">/gitab/</span>etc:<span class="regexp">/etc/gi</span>tlab --name gitlab gitlab:<span class="number">1</span> </span><br><span class="line"></span><br><span class="line">ps:这里是我将老的容器commit提交了下</span><br><span class="line">  docker commit gitlab</span><br><span class="line">  docker tag 镜像ID gitlab:<span class="number">1</span></span><br><span class="line">  docker save -o gitlab.tar gitlab:<span class="number">1</span></span><br><span class="line">  docker load -i gitlab.tar <span class="comment">#这个需要到新的机器上执行</span></span><br></pre></td></tr></table></figure><p>4.进入新的容器中进行恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/opt/gitlab/backups</span><br><span class="line">gitlab-ctl stop</span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1393994389</span><br><span class="line">ps:这里会有提示输入yes即可</span><br></pre></td></tr></table></figure><p>5.重启容器,进行测试看是否少数据</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;我司原有的gitlab仓库运行时间久了,加上机器快到期.刚好可以更换服务器&lt;/p&gt;
&lt;h2 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; class=&quot;headerlink&quot; title=&quot;备份&quot;&gt;&lt;/a&gt;备份&lt;/h2&gt;&lt;p&gt;1.对原有的容器进行备份,/etc/gitlab放置了gitlab的配置文件,这个很重要不然后你后面恢复会找不到项目仓库的.&lt;/p&gt;</summary>
    
    
    
    <category term="记录" scheme="https://www.misslegu.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="技术" scheme="https://www.misslegu.com/categories/%E8%AE%B0%E5%BD%95/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch开启用户密码登录</title>
    <link href="https://www.misslegu.com/2020/04/22/ElasticSearch%E5%BC%80%E5%90%AF%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>https://www.misslegu.com/2020/04/22/ElasticSearch%E5%BC%80%E5%90%AF%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</id>
    <published>2020-04-22T03:33:00.000Z</published>
    <updated>2020-04-22T03:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ElasticSearch开启用户验证"><a href="#ElasticSearch开启用户验证" class="headerlink" title="ElasticSearch开启用户验证"></a>ElasticSearch开启用户验证</h2><p>1.需要在配置文件中开启x-pack验证, 修改config目录下面的elasticsearch.yml文件，在里面添加如下内容,并重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>2.设置用户密码</p><!-- more --><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-setup-passwords interactive</span><br><span class="line">Initiating the setup of passwords <span class="keyword">for</span> reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to <span class="built_in">continue</span> [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Enter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [kibana]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [kibana]: </span><br><span class="line">Enter password <span class="keyword">for</span> [logstash_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [logstash_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [beats_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [beats_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [remote_monitoring_user]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [remote_monitoring_user]: </span><br><span class="line">Changed password <span class="keyword">for</span> user [apm_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [kibana]</span><br><span class="line">Changed password <span class="keyword">for</span> user [logstash_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [beats_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [remote_monitoring_user]</span><br><span class="line">Changed password <span class="keyword">for</span> user [elastic]</span><br></pre></td></tr></table></figure><p>3.在kibana中config下面kibana.yml文件中增加配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.username: <span class="string">&quot;elastic&quot;</span></span><br><span class="line">elasticsearch.password: <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure><p>ps:注意要重启kibana</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ElasticSearch开启用户验证&quot;&gt;&lt;a href=&quot;#ElasticSearch开启用户验证&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch开启用户验证&quot;&gt;&lt;/a&gt;ElasticSearch开启用户验证&lt;/h2&gt;&lt;p&gt;1.需要在配置文件中开启x-pack验证, 修改config目录下面的elasticsearch.yml文件，在里面添加如下内容,并重启&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xpack.security.enabled: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="elasticsearch" scheme="https://www.misslegu.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Linux下普通用户使用docker</title>
    <link href="https://www.misslegu.com/2020/04/22/Linux%E4%B8%8B%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8docker/"/>
    <id>https://www.misslegu.com/2020/04/22/Linux%E4%B8%8B%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8docker/</id>
    <published>2020-04-22T02:37:00.000Z</published>
    <updated>2020-04-22T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建docker组"><a href="#创建docker组" class="headerlink" title="创建docker组"></a>创建docker组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd docker</span><br></pre></td></tr></table></figure><h2 id="将当前用户加入docker用户组"><a href="#将当前用户加入docker用户组" class="headerlink" title="将当前用户加入docker用户组"></a>将当前用户加入docker用户组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="重新启动docker服务（下面是CentOS7的命令）"><a href="#重新启动docker服务（下面是CentOS7的命令）" class="headerlink" title="重新启动docker服务（下面是CentOS7的命令）"></a>重新启动docker服务（下面是CentOS7的命令）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp12adskpuoxodbkqzjfZ:$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;创建docker组&quot;&gt;&lt;a href=&quot;#创建docker组&quot; class=&quot;headerlink&quot; title=&quot;创建docker组&quot;&gt;&lt;/a&gt;创建docker组&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;groupadd docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;将当前用户加入docker用户组&quot;&gt;&lt;a href=&quot;#将当前用户加入docker用户组&quot; class=&quot;headerlink&quot; title=&quot;将当前用户加入docker用户组&quot;&gt;&lt;/a&gt;将当前用户加入docker用户组&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpasswd -a &lt;span class=&quot;variable&quot;&gt;$&amp;#123;USER&amp;#125;&lt;/span&gt; docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://www.misslegu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx开启目录下载</title>
    <link href="https://www.misslegu.com/2020/04/13/Nginx%E5%BC%80%E5%90%AF%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%BD%BD/"/>
    <id>https://www.misslegu.com/2020/04/13/Nginx%E5%BC%80%E5%90%AF%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-04-13T10:41:00.000Z</published>
    <updated>2020-04-13T10:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP目录清单生成模块（HTTP Auto Index）  </p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这个模块提供自动目录列表。<br>连接请求仅在ngx_http_index_module中没有找到主页文件时才会请求这个模块。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;  </span><br><span class="line">          autoindex on; <span class="comment">#开启目录浏览下载功能</span></span><br><span class="line">                      &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二级目录时也可以使用此功能 </p><pre><code>                   localtion /download/&#123;                       autoindex on; #开启目录浏览下载功能                       autoindex_exact_size off;#指定文件大小显示为M默认是b                       autoindex_localtime on;  #开启以服务器本地时区显示文件修改日期  默认为 off，以 GMT 时间作为显示的文件时间；                         alias /home/test/;                    &#125;</code></pre><p>配置完成后，保存，重启nginx通过浏览器访问该路径时,会有如下效果。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>autoindex<br>语法：autoindex [ on|off ]<br>默认值：autoindex off<br>使用字段：http, server, location<br>是否使用自动目录列表。</p><p>autoindex_exact_size<br>语法：autoindex_exact_size [ on|off ]<br>默认值：autoindex_exact_size on<br>使用字段：http, server, location<br>指定生成的自动目录文件大小，可以是精确到bytes或者使用KB, MB或GB。</p><p>autoindex_localtime<br>语法：autoindex_localtime [ on|off ]<br>默认值：autoindex_localtime off<br>使用字段：http, server, location<br>是否在目录列表文件中显示本地时间（GMT时间），默认为关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTP目录清单生成模块（HTTP Auto Index）  &lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;这个模块提供自动目录列表。&lt;br&gt;连接请求仅在ngx_http_index_module中没有找到主页文件时才会请求这个模块。 &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location / &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          autoindex on; &lt;span class=&quot;comment&quot;&gt;#开启目录浏览下载功能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>记录:使用docker-compose搭建zabbix监控系统</title>
    <link href="https://www.misslegu.com/2020/04/10/%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.misslegu.com/2020/04/10/%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-10T08:40:00.000Z</published>
    <updated>2020-04-10T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>使用zabbix来监控各个系统的性能(硬盘,CPU,内存)<br>用来监控web服务器的流量和状态<br>监控tomcat的状态(JVM,GC)  </p><a id="more"></a><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。<br>Compose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="需要创建目录"><a href="#需要创建目录" class="headerlink" title="需要创建目录"></a>需要创建目录</h2><p>在soft目录下创建{web,zabbix-server,mysql,zabbix-agent}的目录 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./soft/&#123;web,zabbix-server,mysql,zabbix-agent&#125;  </span><br></pre></td></tr></table></figure><h2 id="在soft目录下创建一个docker-compose-yml的文件"><a href="#在soft目录下创建一个docker-compose-yml的文件" class="headerlink" title="在soft目录下创建一个docker-compose.yml的文件"></a>在soft目录下创建一个docker-compose.yml的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure><h2 id="在docker-compose-yml输入"><a href="#在docker-compose-yml输入" class="headerlink" title="在docker-compose.yml输入"></a>在docker-compose.yml输入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">zabbix-mysql:</span><br><span class="line">   image: mysql:5.7</span><br><span class="line">   container_name: zabbix-mysql</span><br><span class="line">   environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: User_Password</span><br><span class="line">     MYSQL_DATABASE: zabbix</span><br><span class="line">     MYSQL_USER: zabbix</span><br><span class="line">     MYSQL_PASSWORD: User_Password</span><br><span class="line">   volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">zabbix-server:</span><br><span class="line">    image: zabbix/zabbix-server-mysql:latest</span><br><span class="line">    container_name: zabbix-server</span><br><span class="line">    environment:</span><br><span class="line">      DB_SERVER_HOST: <span class="string">&quot;zabbix-mysql&quot;</span></span><br><span class="line">      MYSQL_DATABASE: zabbix</span><br><span class="line">      MYSQL_USER: root</span><br><span class="line">      MYSQL_PASSWORD: User_Password</span><br><span class="line">      MYSQL_ROOT_PASSWORD: User_Password</span><br><span class="line">    volumes:</span><br><span class="line">      - ./zabbix-server:/usr/lib/zabbix/</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&#x27;10051:10051&#x27;</span></span><br><span class="line">    links:</span><br><span class="line">      - zabbix-mysql</span><br><span class="line">      - zabbix-agent  </span><br><span class="line">zabbix-web:</span><br><span class="line">    image: zabbix/zabbix-web-nginx-mysql:latest</span><br><span class="line">    container_name: zabbix-web</span><br><span class="line">    environment:</span><br><span class="line">      DB_SERVER_HOST: <span class="string">&quot;zabbix-mysql&quot;</span></span><br><span class="line">      MYSQL_DATABASE: zabbix</span><br><span class="line">      MYSQL_USER: zabbix</span><br><span class="line">      MYSQL_PASSWORD: User_Password</span><br><span class="line">      MYSQL_ROOT_PASSWORD: User_Password</span><br><span class="line">      ZBX_SERVER_HOST: zabbix-server</span><br><span class="line">      PHP_TZ: Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - ./web:/usr/lib/zabbix</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">      - 443:443</span><br><span class="line">    links:</span><br><span class="line">      - zabbix-server</span><br><span class="line">      - zabbix-mysql</span><br><span class="line"></span><br><span class="line">zabbix-agent:</span><br><span class="line">    image: zabbix/zabbix-agent:latest</span><br><span class="line">    container_name: zabbix-agent</span><br><span class="line">    environment:</span><br><span class="line">      ZBX_HOSTNAME: zabbix server</span><br><span class="line">      ZBX_SERVER_HOST: 127.0.0.1</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&#x27;10050:10050&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="然后使用docker-compose-up-d启动"><a href="#然后使用docker-compose-up-d启动" class="headerlink" title="然后使用docker-compose up -d启动"></a>然后使用docker-compose up -d启动</h2><h2 id="启动完成检测"><a href="#启动完成检测" class="headerlink" title="启动完成检测"></a>启动完成检测</h2><p>先进入zabbix-web容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it zabbix-web /bin/bash</span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure><p>在使用docker ps -a 检测容器是否启动成功<br>如果没有启动成功请使用docker logs -t container_name查看容器日志<br>如:常见故障可能是没有连接到数据库</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;p&gt;使用zabbix来监控各个系统的性能(硬盘,CPU,内存)&lt;br&gt;用来监控web服务器的流量和状态&lt;br&gt;监控tomcat的状态(JVM,GC)  &lt;/p&gt;</summary>
    
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="记录" scheme="https://www.misslegu.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LInux 常见的服务端口</title>
    <link href="https://www.misslegu.com/2020/03/27/LInux-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3/"/>
    <id>https://www.misslegu.com/2020/03/27/LInux-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3/</id>
    <published>2020-03-27T11:06:00.000Z</published>
    <updated>2020-03-27T11:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>被动端口20/主动端口21 (文件传输协议)</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>端口53 (域名系统协议)</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>端口68 (动态主机配置协议)</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>端口22 (安全外壳协议)</p><a id="more"></a><h1 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h1><p>端口23 </p><h1 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h1><p>25 (简单邮件传输协议)</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>端口6379</p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>端口3306</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>端口80</p><h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>端口80</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>端口443</p><h1 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a>NTP</h1><p>端口123 (网络时间协议)</p><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>端口 8080</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FTP&quot;&gt;&lt;a href=&quot;#FTP&quot; class=&quot;headerlink&quot; title=&quot;FTP&quot;&gt;&lt;/a&gt;FTP&lt;/h1&gt;&lt;p&gt;被动端口20/主动端口21 (文件传输协议)&lt;/p&gt;
&lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;p&gt;端口53 (域名系统协议)&lt;/p&gt;
&lt;h1 id=&quot;DHCP&quot;&gt;&lt;a href=&quot;#DHCP&quot; class=&quot;headerlink&quot; title=&quot;DHCP&quot;&gt;&lt;/a&gt;DHCP&lt;/h1&gt;&lt;p&gt;端口68 (动态主机配置协议)&lt;/p&gt;
&lt;h1 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h1&gt;&lt;p&gt;端口22 (安全外壳协议)&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>进程 线程 守护进程的区别</title>
    <link href="https://www.misslegu.com/2020/03/27/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.misslegu.com/2020/03/27/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-27T10:46:00.000Z</published>
    <updated>2020-03-27T10:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h1><p>进程(Process)是计算机中已运行程序的实体。用户下达运行程序的命令后，就会产生进程。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。</p><h2 id="进程和程序是有本质区别的"><a href="#进程和程序是有本质区别的" class="headerlink" title="进程和程序是有本质区别的"></a>进程和程序是有本质区别的</h2><p>程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念；<br>而进程是一个动态的概念，它是程序执行的过程，包括了动态创建、调度和消亡的整个过程；<br>它是程序执行和资源管理的最小单位。</p><a id="more"></a><h2 id="进行状态"><a href="#进行状态" class="headerlink" title="进行状态"></a>进行状态</h2><p>通过ps aux可以看到进程的状态。</p><p>O：进程正在处理器运行,这个状态从来没有见过.<br>S：休眠状态（sleeping）<br>R：等待运行（runable）R Running or runnable (on run queue) 进程处于运行或就绪状态<br>I：空闲状态（idle）<br>Z：僵尸状态（zombie）<br>T：跟踪状态（Traced）<br>B：进程正在等待更多的内存页<br>D: 不可中断的深度睡眠，一般由IO引起，同步IO在做读或写操作时，cpu不能做其它事情，只能等待，这时进程处于这种状态，如果程序采用异步IO，这种状态应该就很少见到了  </p><p>其中就绪状态表示进程已经分配到除CPU以外的资源，等CPU调度它时就可以马上执行了。运行状态就是正在运行了，获得包括CPU在内的所有资源。等待状态表示因等待某个事件而没有被执行，这时候不耗CPU时间，而这个时间有可能是等待IO、申请不到足够的缓冲区或者在等待信号。</p><h1 id="前台进程跟守护进程的区别"><a href="#前台进程跟守护进程的区别" class="headerlink" title="前台进程跟守护进程的区别"></a>前台进程跟守护进程的区别</h1><p>LINUX后台进程也叫守护进程（Daemon），是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。 </p><p>一般用作系统服务，可以用crontab提交，编辑或者删除相应得作业。 </p><p>守护的意思就是不受终端控制。Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器inetd，Web服务器httpd等。同时，守护进程完成许多系统任务。比如，作业规划进程crond，打印进程lpd等。 </p><p>前台进程就是用户使用的有控制终端的进程 </p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</span><br><span class="line"></span><br><span class="line">2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</span><br><span class="line"></span><br><span class="line">3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</span><br><span class="line"></span><br><span class="line">4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</span><br><span class="line"></span><br><span class="line">5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h1&gt;&lt;p&gt;进程(Process)是计算机中已运行程序的实体。用户下达运行程序的命令后，就会产生进程。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。&lt;/p&gt;
&lt;h2 id=&quot;进程和程序是有本质区别的&quot;&gt;&lt;a href=&quot;#进程和程序是有本质区别的&quot; class=&quot;headerlink&quot; title=&quot;进程和程序是有本质区别的&quot;&gt;&lt;/a&gt;进程和程序是有本质区别的&lt;/h2&gt;&lt;p&gt;程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念；&lt;br&gt;而进程是一个动态的概念，它是程序执行的过程，包括了动态创建、调度和消亡的整个过程；&lt;br&gt;它是程序执行和资源管理的最小单位。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.misslegu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术" scheme="https://www.misslegu.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
